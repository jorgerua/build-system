
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shared: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/oci-build-system/libs/shared/config.go (85.9%)</option>
				
				<option value="file1">github.com/oci-build-system/libs/shared/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package shared

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/spf13/viper"
        "go.uber.org/zap"
)

// Config representa a configuração completa do sistema
type Config struct {
        Server  ServerConfig  `mapstructure:"server"`
        NATS    NATSConfig    `mapstructure:"nats"`
        GitHub  GitHubConfig  `mapstructure:"github"`
        Auth    AuthConfig    `mapstructure:"auth"`
        Worker  WorkerConfig  `mapstructure:"worker"`
        Build   BuildConfig   `mapstructure:"build"`
        Logging LoggingConfig `mapstructure:"logging"`
}

// ServerConfig contém configurações do servidor HTTP
type ServerConfig struct {
        Port            int `mapstructure:"port"`
        ReadTimeout     int `mapstructure:"read_timeout"`
        WriteTimeout    int `mapstructure:"write_timeout"`
        ShutdownTimeout int `mapstructure:"shutdown_timeout"`
}

// NATSConfig contém configurações do NATS
type NATSConfig struct {
        URL            string        `mapstructure:"url"`
        ReconnectWait  time.Duration `mapstructure:"reconnect_wait"`
        ConnectTimeout time.Duration `mapstructure:"connect_timeout"`
}

// GitHubConfig contém configurações do GitHub
type GitHubConfig struct {
        WebhookSecret string `mapstructure:"webhook_secret"`
}

// AuthConfig contém configurações de autenticação
type AuthConfig struct {
        Token string `mapstructure:"token"`
}

// WorkerConfig contém configurações do worker
type WorkerConfig struct {
        PoolSize   int           `mapstructure:"pool_size"`
        QueueSize  int           `mapstructure:"queue_size"`
        Timeout    int           `mapstructure:"timeout"`
        MaxRetries int           `mapstructure:"max_retries"`
        RetryDelay time.Duration `mapstructure:"retry_delay"`
}

// BuildConfig contém configurações de build
type BuildConfig struct {
        CodeCachePath  string `mapstructure:"code_cache_path"`
        BuildCachePath string `mapstructure:"build_cache_path"`
}

// LoggingConfig contém configurações de logging
type LoggingConfig struct {
        Level  string `mapstructure:"level"`
        Format string `mapstructure:"format"`
}

// LoadConfig carrega a configuração de um arquivo YAML com suporte a variáveis de ambiente
func LoadConfig(configPath string, logger *zap.Logger) (*Config, error) <span class="cov4" title="3">{
        viper.SetConfigFile(configPath)
        viper.SetConfigType("yaml")
        
        // Permitir override via variáveis de ambiente
        viper.AutomaticEnv()
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        // Ler arquivo de configuração
        if err := viper.ReadInConfig(); err != nil </span><span class="cov1" title="1">{
                logger.Warn("Failed to read config file, using environment variables only",
                        zap.String("config_path", configPath),
                        zap.Error(err))
        }</span>

        <span class="cov4" title="3">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        // Expandir variáveis de ambiente em strings de configuração
        <span class="cov4" title="3">expandEnvVars(&amp;config)

        // Validar configuração obrigatória
        if err := validateConfig(&amp;config, logger); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        // Log configuração carregada (sem secrets)
        <span class="cov4" title="3">logConfig(&amp;config, logger)

        return &amp;config, nil</span>
}

// expandEnvVars expande variáveis de ambiente em formato ${VAR_NAME}
func expandEnvVars(config *Config) <span class="cov7" title="8">{
        config.GitHub.WebhookSecret = os.ExpandEnv(config.GitHub.WebhookSecret)
        config.Auth.Token = os.ExpandEnv(config.Auth.Token)
        config.NATS.URL = os.ExpandEnv(config.NATS.URL)
        config.Build.CodeCachePath = os.ExpandEnv(config.Build.CodeCachePath)
        config.Build.BuildCachePath = os.ExpandEnv(config.Build.BuildCachePath)
}</span>

// validateConfig valida os campos obrigatórios da configuração
func validateConfig(config *Config, logger *zap.Logger) error <span class="cov10" title="16">{
        var errors []string

        // Validar GitHub webhook secret
        if config.GitHub.WebhookSecret == "" || config.GitHub.WebhookSecret == "${GITHUB_WEBHOOK_SECRET}" </span><span class="cov3" title="2">{
                errors = append(errors, "GITHUB_WEBHOOK_SECRET is required but not set")
        }</span>

        // Validar auth token
        <span class="cov10" title="16">if config.Auth.Token == "" || config.Auth.Token == "${API_AUTH_TOKEN}" </span><span class="cov3" title="2">{
                errors = append(errors, "API_AUTH_TOKEN is required but not set")
        }</span>

        // Validar NATS
        <span class="cov10" title="16">if config.NATS.URL == "" </span><span class="cov1" title="1">{
                errors = append(errors, "NATS URL is required but not set")
        }</span>

        // Validar Server (apenas se configurado)
        <span class="cov10" title="16">if config.Server.Port != 0 </span><span class="cov7" title="7">{
                if config.Server.Port &lt; 1 || config.Server.Port &gt; 65535 </span><span class="cov1" title="1">{
                        errors = append(errors, fmt.Sprintf("invalid server port: %d", config.Server.Port))
                }</span>
                <span class="cov7" title="7">if config.Server.ReadTimeout &lt; 0 </span><span class="cov1" title="1">{
                        errors = append(errors, "server read timeout cannot be negative")
                }</span>
                <span class="cov7" title="7">if config.Server.WriteTimeout &lt; 0 </span><span class="cov1" title="1">{
                        errors = append(errors, "server write timeout cannot be negative")
                }</span>
                <span class="cov7" title="7">if config.Server.ShutdownTimeout &lt; 0 </span><span class="cov0" title="0">{
                        errors = append(errors, "server shutdown timeout cannot be negative")
                }</span>
        }

        // Validar Worker (apenas se configurado)
        <span class="cov10" title="16">if config.Worker.PoolSize != 0 </span><span class="cov5" title="4">{
                if config.Worker.PoolSize &lt; 1 </span><span class="cov0" title="0">{
                        errors = append(errors, "worker pool size must be at least 1")
                }</span>
                <span class="cov5" title="4">if config.Worker.Timeout &lt; 0 </span><span class="cov3" title="2">{
                        errors = append(errors, "worker timeout cannot be negative")
                }</span>
                <span class="cov5" title="4">if config.Worker.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                        errors = append(errors, "worker max retries cannot be negative")
                }</span>
        }

        // Validar Build (apenas se configurado)
        <span class="cov10" title="16">if config.Build.CodeCachePath != "" || config.Build.BuildCachePath != "" </span><span class="cov3" title="2">{
                if config.Build.CodeCachePath == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "build code cache path is required when build config is present")
                }</span>
                <span class="cov3" title="2">if config.Build.BuildCachePath == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "build build cache path is required when build config is present")
                }</span>
        }

        // Validar paths de cache (se configurados)
        <span class="cov10" title="16">if config.Build.CodeCachePath != "" </span><span class="cov3" title="2">{
                if err := validateCachePath(config.Build.CodeCachePath); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("invalid code cache path: %v", err))
                }</span>
        }
        <span class="cov10" title="16">if config.Build.BuildCachePath != "" </span><span class="cov3" title="2">{
                if err := validateCachePath(config.Build.BuildCachePath); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("invalid build cache path: %v", err))
                }</span>
        }

        // Validar Logging
        <span class="cov10" title="16">if config.Logging.Level != "" </span><span class="cov6" title="5">{
                validLevels := map[string]bool{
                        "debug": true,
                        "info":  true,
                        "warn":  true,
                        "error": true,
                        "fatal": true,
                }
                if !validLevels[config.Logging.Level] </span><span class="cov1" title="1">{
                        errors = append(errors, "logging level must be one of: debug, info, warn, error, fatal")
                }</span>
        }

        <span class="cov10" title="16">if config.Logging.Format != "" </span><span class="cov6" title="5">{
                if config.Logging.Format != "json" &amp;&amp; config.Logging.Format != "text" </span><span class="cov1" title="1">{
                        errors = append(errors, "logging format must be either 'json' or 'text'")
                }</span>
        }

        <span class="cov10" title="16">if len(errors) &gt; 0 </span><span class="cov9" title="12">{
                return fmt.Errorf("configuration validation failed:\n  - %s", strings.Join(errors, "\n  - "))
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// validateCachePath verifica se path de cache existe e é gravável
func validateCachePath(path string) error <span class="cov8" title="9">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov4" title="3">{
                if os.IsNotExist(err) </span><span class="cov4" title="3">{
                        // Tentar criar o diretório
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("cache path does not exist and cannot be created: %w", err)
                        }</span>
                        <span class="cov3" title="2">return nil</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov6" title="6">if !info.IsDir() </span><span class="cov1" title="1">{
                return fmt.Errorf("cache path is not a directory")
        }</span>

        // Testar se é gravável
        <span class="cov6" title="5">testFile := filepath.Join(path, ".write-test")
        if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache path is not writable: %w", err)
        }</span>
        <span class="cov6" title="5">os.Remove(testFile)

        return nil</span>
}

// logConfig registra configuração carregada (sem expor secrets)
func logConfig(config *Config, logger *zap.Logger) <span class="cov5" title="4">{
        logger.Info("Configuration loaded",
                zap.Int("server_port", config.Server.Port),
                zap.String("nats_url", config.NATS.URL),
                zap.String("log_level", config.Logging.Level),
                zap.String("log_format", config.Logging.Format),
                zap.Bool("github_secret_set", config.GitHub.WebhookSecret != ""),
                zap.Bool("auth_token_set", config.Auth.Token != ""),
                zap.String("code_cache_path", config.Build.CodeCachePath),
                zap.String("build_cache_path", config.Build.BuildCachePath),
        )
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package shared

import (
        "time"
)

// JobStatus representa o status de um job de build
type JobStatus string

const (
        JobStatusPending   JobStatus = "pending"
        JobStatusRunning   JobStatus = "running"
        JobStatusSuccess   JobStatus = "success"
        JobStatusFailed    JobStatus = "failed"
        JobStatusCancelled JobStatus = "cancelled"
)

// IsValid verifica se o status é válido
func (s JobStatus) IsValid() bool <span class="cov9" title="10">{
        switch s </span>{
        case JobStatusPending, JobStatusRunning, JobStatusSuccess, JobStatusFailed, JobStatusCancelled:<span class="cov8" title="7">
                return true</span>
        default:<span class="cov5" title="3">
                return false</span>
        }
}

// IsTerminal verifica se o status é terminal (não pode mais mudar)
func (s JobStatus) IsTerminal() bool <span class="cov7" title="5">{
        return s == JobStatusSuccess || s == JobStatusFailed || s == JobStatusCancelled
}</span>

// BuildPhase representa uma fase do processo de build
type BuildPhase string

const (
        BuildPhaseGitSync   BuildPhase = "git_sync"
        BuildPhaseNXBuild   BuildPhase = "nx_build"
        BuildPhaseImageBuild BuildPhase = "image_build"
)

// IsValid verifica se a fase é válida
func (p BuildPhase) IsValid() bool <span class="cov7" title="5">{
        switch p </span>{
        case BuildPhaseGitSync, BuildPhaseNXBuild, BuildPhaseImageBuild:<span class="cov5" title="3">
                return true</span>
        default:<span class="cov3" title="2">
                return false</span>
        }
}

// Language representa uma linguagem de programação suportada
type Language string

const (
        LanguageJava   Language = "java"
        LanguageDotNet Language = "dotnet"
        LanguageGo     Language = "go"
        LanguageUnknown Language = "unknown"
)

// IsValid verifica se a linguagem é válida
func (l Language) IsValid() bool <span class="cov9" title="10">{
        switch l </span>{
        case LanguageJava, LanguageDotNet, LanguageGo, LanguageUnknown:<span class="cov8" title="7">
                return true</span>
        default:<span class="cov5" title="3">
                return false</span>
        }
}

// IsSupported verifica se a linguagem é suportada (não unknown)
func (l Language) IsSupported() bool <span class="cov7" title="5">{
        return l != LanguageUnknown &amp;&amp; l.IsValid()
}</span>

// RepositoryInfo contém informações sobre um repositório
type RepositoryInfo struct {
        URL   string `json:"url"`
        Name  string `json:"name"`
        Owner string `json:"owner"`
        Branch string `json:"branch"`
}

// FullName retorna o nome completo do repositório (owner/name)
func (r *RepositoryInfo) FullName() string <span class="cov6" title="4">{
        if r.Owner == "" || r.Name == "" </span><span class="cov5" title="3">{
                return ""
        }</span>
        <span class="cov1" title="1">return r.Owner + "/" + r.Name</span>
}

// IsValid verifica se as informações do repositório são válidas
func (r *RepositoryInfo) IsValid() bool <span class="cov9" title="9">{
        return r.URL != "" &amp;&amp; r.Name != "" &amp;&amp; r.Owner != ""
}</span>

// PhaseMetric contém métricas de uma fase do build
type PhaseMetric struct {
        Phase     BuildPhase    `json:"phase"`
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
        Success   bool          `json:"success"`
        Error     string        `json:"error,omitempty"`
}

// IsComplete verifica se a métrica está completa (tem start e end time)
func (m *PhaseMetric) IsComplete() bool <span class="cov7" title="6">{
        return !m.StartTime.IsZero() &amp;&amp; !m.EndTime.IsZero()
}</span>

// CalculateDuration calcula a duração baseada nos timestamps
func (m *PhaseMetric) CalculateDuration() <span class="cov3" title="2">{
        if m.IsComplete() </span><span class="cov1" title="1">{
                m.Duration = m.EndTime.Sub(m.StartTime)
        }</span>
}

// BuildJob representa um job de build na fila
type BuildJob struct {
        ID           string          `json:"id"`
        Repository   RepositoryInfo  `json:"repository"`
        CommitHash   string          `json:"commit_hash"`
        CommitAuthor string          `json:"commit_author"`
        CommitMsg    string          `json:"commit_message"`
        Branch       string          `json:"branch"`
        Status       JobStatus       `json:"status"`
        CreatedAt    time.Time       `json:"created_at"`
        StartedAt    *time.Time      `json:"started_at,omitempty"`
        CompletedAt  *time.Time      `json:"completed_at,omitempty"`
        Duration     time.Duration   `json:"duration"`
        Error        string          `json:"error,omitempty"`
        Phases       []PhaseMetric   `json:"phases"`
}

// IsValid verifica se o job é válido
func (j *BuildJob) IsValid() bool <span class="cov7" title="6">{
        return j.ID != "" &amp;&amp; j.Repository.IsValid() &amp;&amp; j.CommitHash != "" &amp;&amp; j.Status.IsValid()
}</span>

// MarkStarted marca o job como iniciado
func (j *BuildJob) MarkStarted() <span class="cov3" title="2">{
        now := time.Now()
        j.StartedAt = &amp;now
        j.Status = JobStatusRunning
}</span>

// MarkCompleted marca o job como completado com sucesso
func (j *BuildJob) MarkCompleted() <span class="cov3" title="2">{
        now := time.Now()
        j.CompletedAt = &amp;now
        j.Status = JobStatusSuccess
        j.CalculateDuration()
}</span>

// MarkFailed marca o job como falho
func (j *BuildJob) MarkFailed(err string) <span class="cov1" title="1">{
        now := time.Now()
        j.CompletedAt = &amp;now
        j.Status = JobStatusFailed
        j.Error = err
        j.CalculateDuration()
}</span>

// MarkCancelled marca o job como cancelado
func (j *BuildJob) MarkCancelled() <span class="cov1" title="1">{
        now := time.Now()
        j.CompletedAt = &amp;now
        j.Status = JobStatusCancelled
        j.CalculateDuration()
}</span>

// CalculateDuration calcula a duração total do job
func (j *BuildJob) CalculateDuration() <span class="cov7" title="6">{
        if j.StartedAt != nil &amp;&amp; j.CompletedAt != nil </span><span class="cov7" title="5">{
                j.Duration = j.CompletedAt.Sub(*j.StartedAt)
        }</span>
}

// AddPhase adiciona uma métrica de fase ao job
func (j *BuildJob) AddPhase(phase PhaseMetric) <span class="cov6" title="4">{
        j.Phases = append(j.Phases, phase)
}</span>

// GetPhase retorna a métrica de uma fase específica
func (j *BuildJob) GetPhase(phase BuildPhase) *PhaseMetric <span class="cov8" title="7">{
        for i := range j.Phases </span><span class="cov10" title="11">{
                if j.Phases[i].Phase == phase </span><span class="cov7" title="5">{
                        return &amp;j.Phases[i]
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// HasPhase verifica se o job tem uma fase específica
func (j *BuildJob) HasPhase(phase BuildPhase) bool <span class="cov7" title="5">{
        return j.GetPhase(phase) != nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
