
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nats-client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/oci-build-system/libs/nats-client/client.go (83.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package natsclient

import (
        "context"
        "fmt"
        "time"

        "github.com/nats-io/nats.go"
        "go.uber.org/zap"
)

// NATSClient define a interface para o cliente NATS
type NATSClient interface {
        Connect(url string) error
        Publish(subject string, data []byte) error
        Subscribe(subject string, handler nats.MsgHandler) (*nats.Subscription, error)
        Request(subject string, data []byte, timeout time.Duration) (*nats.Msg, error)
        Close()
        IsConnected() bool
}

// Client implementa a interface NATSClient
type Client struct {
        conn   *nats.Conn
        logger *zap.Logger
        url    string
}

// Config contém as configurações do cliente NATS
type Config struct {
        URL            string
        MaxReconnects  int
        ReconnectWait  time.Duration
        ConnectTimeout time.Duration
}

// DefaultConfig retorna uma configuração padrão
func DefaultConfig() *Config <span class="cov6" title="16">{
        return &amp;Config{
                MaxReconnects:  10,
                ReconnectWait:  2 * time.Second,
                ConnectTimeout: 5 * time.Second,
        }
}</span>

// NewClient cria uma nova instância do cliente NATS
func NewClient(logger *zap.Logger) *Client <span class="cov6" title="21">{
        if logger == nil </span><span class="cov1" title="1">{
                logger = zap.NewNop()
        }</span>
        <span class="cov6" title="21">return &amp;Client{
                logger: logger,
        }</span>
}

// NewClientWithConfig cria uma nova instância do cliente NATS com configuração customizada
func NewClientWithConfig(logger *zap.Logger, config *Config) (*Client, error) <span class="cov2" title="2">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = zap.NewNop()
        }</span>
        
        <span class="cov2" title="2">client := &amp;Client{
                logger: logger,
                url:    config.URL,
        }
        
        if err := client.ConnectWithConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov2" title="2">return client, nil</span>
}

// Connect estabelece conexão com o servidor NATS com retry automático
func (c *Client) Connect(url string) error <span class="cov6" title="15">{
        config := DefaultConfig()
        config.URL = url
        return c.ConnectWithConfig(config)
}</span>

// ConnectWithConfig estabelece conexão com o servidor NATS usando configuração customizada
func (c *Client) ConnectWithConfig(config *Config) error <span class="cov6" title="17">{
        c.url = config.URL
        
        c.logger.Info("connecting to NATS server",
                zap.String("url", config.URL),
                zap.Int("max_reconnects", config.MaxReconnects),
                zap.Duration("reconnect_wait", config.ReconnectWait),
        )

        opts := []nats.Option{
                nats.MaxReconnects(config.MaxReconnects),
                nats.ReconnectWait(config.ReconnectWait),
                nats.Timeout(config.ConnectTimeout),
                nats.DisconnectErrHandler(func(nc *nats.Conn, err error) </span><span class="cov6" title="16">{
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn("disconnected from NATS server",
                                        zap.Error(err),
                                        zap.String("url", nc.ConnectedUrl()),
                                )
                        }</span>
                }),
                nats.ReconnectHandler(func(nc *nats.Conn) <span class="cov0" title="0">{
                        c.logger.Info("reconnected to NATS server",
                                zap.String("url", nc.ConnectedUrl()),
                        )
                }</span>),
                nats.ClosedHandler(func(nc *nats.Conn) <span class="cov6" title="16">{
                        c.logger.Info("connection to NATS server closed",
                                zap.String("url", nc.ConnectedUrl()),
                        )
                }</span>),
                nats.ErrorHandler(func(nc *nats.Conn, sub *nats.Subscription, err error) <span class="cov0" title="0">{
                        c.logger.Error("NATS error",
                                zap.Error(err),
                                zap.String("subject", sub.Subject),
                        )
                }</span>),
        }

        <span class="cov6" title="17">conn, err := nats.Connect(config.URL, opts...)
        if err != nil </span><span class="cov1" title="1">{
                c.logger.Error("failed to connect to NATS server",
                        zap.Error(err),
                        zap.String("url", config.URL),
                )
                return fmt.Errorf("failed to connect to NATS: %w", err)
        }</span>

        <span class="cov6" title="16">c.conn = conn
        c.logger.Info("successfully connected to NATS server",
                zap.String("url", conn.ConnectedUrl()),
                zap.String("server_id", conn.ConnectedServerId()),
        )

        return nil</span>
}

// Publish publica uma mensagem em um subject
func (c *Client) Publish(subject string, data []byte) error <span class="cov10" title="120">{
        if c.conn == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("not connected to NATS server")
        }</span>

        <span class="cov9" title="119">c.logger.Debug("publishing message",
                zap.String("subject", subject),
                zap.Int("size", len(data)),
        )

        if err := c.conn.Publish(subject, data); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to publish message",
                        zap.Error(err),
                        zap.String("subject", subject),
                )
                return fmt.Errorf("failed to publish to %s: %w", subject, err)
        }</span>

        <span class="cov9" title="119">c.logger.Debug("message published successfully",
                zap.String("subject", subject),
        )

        return nil</span>
}

// Subscribe cria uma subscrição para um subject
func (c *Client) Subscribe(subject string, handler nats.MsgHandler) (*nats.Subscription, error) <span class="cov3" title="4">{
        if c.conn == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("not connected to NATS server")
        }</span>

        <span class="cov3" title="3">c.logger.Info("subscribing to subject",
                zap.String("subject", subject),
        )

        // Wrapper do handler para adicionar logging
        wrappedHandler := func(msg *nats.Msg) </span><span class="cov5" title="12">{
                c.logger.Debug("received message",
                        zap.String("subject", msg.Subject),
                        zap.Int("size", len(msg.Data)),
                )
                handler(msg)
        }</span>

        <span class="cov3" title="3">sub, err := c.conn.Subscribe(subject, wrappedHandler)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to subscribe to subject",
                        zap.Error(err),
                        zap.String("subject", subject),
                )
                return nil, fmt.Errorf("failed to subscribe to %s: %w", subject, err)
        }</span>

        <span class="cov3" title="3">c.logger.Info("successfully subscribed to subject",
                zap.String("subject", subject),
        )

        return sub, nil</span>
}

// Request envia uma requisição e aguarda resposta
func (c *Client) Request(subject string, data []byte, timeout time.Duration) (*nats.Msg, error) <span class="cov3" title="3">{
        if c.conn == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("not connected to NATS server")
        }</span>

        <span class="cov2" title="2">c.logger.Debug("sending request",
                zap.String("subject", subject),
                zap.Int("size", len(data)),
                zap.Duration("timeout", timeout),
        )

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        msg, err := c.conn.RequestWithContext(ctx, subject, data)
        if err != nil </span><span class="cov1" title="1">{
                c.logger.Error("request failed",
                        zap.Error(err),
                        zap.String("subject", subject),
                )
                return nil, fmt.Errorf("request to %s failed: %w", subject, err)
        }</span>

        <span class="cov1" title="1">c.logger.Debug("received response",
                zap.String("subject", subject),
                zap.Int("size", len(msg.Data)),
        )

        return msg, nil</span>
}

// Close fecha a conexão com graceful shutdown
func (c *Client) Close() <span class="cov6" title="18">{
        if c.conn == nil </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov6" title="16">c.logger.Info("closing NATS connection",
                zap.String("url", c.url),
        )

        // Drain permite que mensagens pendentes sejam processadas antes de fechar
        if err := c.conn.Drain(); err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("error draining connection",
                        zap.Error(err),
                )
        }</span>

        <span class="cov6" title="16">c.conn.Close()
        c.conn = nil

        c.logger.Info("NATS connection closed")</span>
}

// IsConnected verifica se o cliente está conectado
func (c *Client) IsConnected() bool <span class="cov5" title="9">{
        return c.conn != nil &amp;&amp; c.conn.IsConnected()
}</span>

// Stats retorna estatísticas da conexão
func (c *Client) Stats() nats.Statistics <span class="cov2" title="2">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return nats.Statistics{}
        }</span>
        <span class="cov2" title="2">return c.conn.Stats()</span>
}

// Flush força o envio de mensagens pendentes
func (c *Client) Flush() error <span class="cov3" title="3">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected to NATS server")
        }</span>
        <span class="cov3" title="3">return c.conn.Flush()</span>
}

// FlushTimeout força o envio de mensagens pendentes com timeout
func (c *Client) FlushTimeout(timeout time.Duration) error <span class="cov1" title="1">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected to NATS server")
        }</span>
        <span class="cov1" title="1">return c.conn.FlushTimeout(timeout)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
